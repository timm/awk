#!/usr/bin/env bash
# vim: ft=awk ts=2 sw=2 et :
code() { cat<<'EOF'|gawk -f gold.awk -e '{transpile($0)}' 
#------------------------------------------------
BEGIN { 
  THE.some.max = 256 
  THE.ch.skip = "?" 
  THE.stats.cliff = "?" 
  THE.all.rand  = 1
}
#------------------------------------------------
function add1(i,x, f) {f=i.isa "_add1"; return @f(i.x) }
function loop(i,   f) {f=i.isa "_loop"; return @f(i.x) }
function var(i,    f) {f=i.isa "_var";  return @f(i.x) }
function mid(i,    f) {f=i.isa "_mid";  return @f(i.x) }
#------------------------------------------------
function adds(a,out,fun,    j) { 
  for(j in a) {
    fun = fun?fun:((typeof(a[j])=="number")?"Num":"Sym")
    print(fun)
    @fun(out)
    break
  }
  for(j in a) add(out, a[j])
}

function add(i,x) { 
  if (x != THE.ch.skip)  { i.n++; add1(i,x) }
  return x
}
#------------------------------------------------
function Sym(i) {
  isa(i,"Sym")
  has(i,"seen")
  i.mode = i.most = ""
}
function _add1(i,x) {
  i.seen[x] = i.seen[x] + 1
  if (i.seen[x] > i.most) { i.most=i.seen[x]; i.mode=x}
}
function _mid(i) { return i.mode  }
function _var(i) { return _ent(i) }

function _ent(i,    j,e,n,p) {
  for(j in i.seen) {
    n = i.seen[j]
    if (n > 0) {
      p  = n/i.n
      e -= p*log(p)/log(2) }}
  return e
}
function _score(i,goal,all,     
                  e,y,n,yall,nall,ys,ns,tmp) {
  e    = 0.00001
  y    = i.seen[goal]
  n    = i.n - y
  yall = all.seen[goal] 
  nall = all.n - yall
  ys   = y    / (e+ yall)
  ns   = n    / (e+ nall)
  tmp  = ys**2 / (e+ ys + ns)
  return (i.score = tmp > 0.01 ? tmp : 0)
}
#------------------------------------------------
function Num(i) {
  isa(i,"Num")
  i.hi=-10**32
  i.lo=10**32
  has(i,"Some")
}
function _add1(i, x) {
  add(i.some,x)
  i.hi = max(i.hi,x)
  i.lo = min(i.lo,x)
}
#------------------------------------------------
function Some(i:list0, max:pos) :nil {
  isa(i,"Some")
  i.n=0
  has(i,"all")
  i.ok=1          
  i.max = max ? max : THE.some.max
}

function _add1(i,x, j) {
  if (length(i.all)  < i.max) 
    _update(i, x, length(i.all) + 1)
  else if (rand() < i.max/i.n) 
    _update(i, x, int(0.5+length(i.all)*rand()))
}
function _update(i,x,k) { i.all[k]=x; i.ok=0 }

### Ensure contents are sorted
function _ok(i:Some) :nil  { 
   if (!i.ok) i.ok= asort(i.all) }

function _var(i,  lo,hi) { return (_per(i,.9) - _per(i, .1))/2.54 }
function _mid(i,  lo,hi) { return _per(i,.5,lo,hi) }

function _per(i,p , lo,hi) {
  p  = p?p: 0.5
  lo = lo?lo: 1
  hi = hi?hi: length(i.all)
  _ok(i)
  return i.all[ int(0.5 + lo+p*(hi-lo)) ]
}
function _few(i,few,   j,k) {
  _ok(i)
  k = max(1, int(0.5+ length(i)/ THE.some.max))
  for(j=1; j<=length(i.all); j += k) 
    push( i.all[j], few) 
}
function _same(i,j,   ai,aj) {
  _few(i, ai)
  _few(j, aj)
  return cliffs(ai,aj)
}
#------------------------------------------------
function Rows(i) {
  isa(i,"Rows")
  has(i,"names")
  has(i,"rows")
  has(i,"cols")
}
function _num(s) { return s ~/[:<>]/ }
function _y(s)   { return s ~/[!<>]/ }
function _x(s)   { return ! y(s) }
function _sym(s) { return ! num(s) }

function _want(i,out,want1,want2) {
  for(i in i.names)
    if (@want1(i.names[i]) ||  want2 && @want2(i.wants[i]))
      out[i] = i
}
function _reads(i, file, ing) {
  Cols(ing)
  while(loop(ing)) oo(ing.it)
}
#------------------------------------------------
function Cols(i,file) {
  isa(i,"Cols")
  i.file = file
  has(i,"get")
  has(i,"it")
} 
function _loop(i,   a,ok,j,n,get) {
  ok = csv(a,i.file) 
  if (!ok) return 0
  if (!length(i.use))   
    for(j in a)
      if (a[j] !~ THE.char.skip)  
        i.get[++n] = j ;
  for(j in i.get) 
     i.it[j] = a[i.get[j]]
  return 1
}
#------------------------------------------------
function cliffs(as,bs,t,    a,b,n,lt,gt) {
  t= t? t : THE.stats.cliff
  for(a in as)
   for(b in bs) {
     n++
     if (as[a] < bs[b]) lt++
     if (as[a] > bs[b]) gt++
  }
  return abs(lt-gt)/n < t
}
#------------------------------------------------
function egFail(f) { ok(f,1==2) }
function egPass(f) { ok(f,1==1) }
function egSym(f, s) {
  Sym(s)
  oo(s)
}
function egSyms(f, s,a,tmp) {
  split("aaaaabbc",a,"")
  adds(a,tmp,"Sym")
  assert(1.378 <= var(tmp) && var(tmp) <= 1.379)
  #s=adds({"a","a","a","a","a","a","a"},Sym.new())
  #assert(s:ent()==0)

}
#------------------------------------------------
BEGIN { allegs(); rogues() }
EOF
}
code > /tmp/$$gold.awk;gawk -f gold.awk -f /tmp/$$gold.awk
