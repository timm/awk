# vim: ft=awk ts=2 sw=2 et :
# hold just  some things in a column (reservoir sampling)
function Some(i:list0, max:pos) :nil {
  isa(i,"Some")
  i.n=0
  has(i,"all")
  i.ok=1          
  i.max = max ? max : THE.some.max
}

function _add1(i,x, j) {
  if (length(i.all)  < i.max) 
    _update(i, x, length(i.all) + 1)
  else if (rand() < i.max/i.n) 
    _update(i, x, int(0.5+length(i.all)*rand()))
}
function _update(i,x,k) { i.all[k]=x; i.ok=0 }

### Ensure contents are sorted
function _ok(i:Some) :nil  { 
   if (!i.ok) i.ok= asort(i.all) }

function _var(i,  lo,hi) { return (_per(i,.9) - _per(i, .1))/2.54 }
function _mid(i,  lo,hi) { return _per(i,.5,lo,hi) }

function _per(i,p , lo,hi) {
  p  = p?p: 0.5
  lo = lo?lo: 1
  hi = hi?hi: length(i.all)
  _ok(i)
  return i.all[ int(0.5 + lo+p*(hi-lo)) ]
}
function _few(i,few,   j,k) {
  _ok(i)
  k = max(1, int(0.5+ length(i)/ THE.some.max))
  for(j=1; j<=length(i.all); j += k) 
    push( i.all[j], few) 
}
function _same(i,j,   ai,aj) {
  _few(i, ai)
  _few(j, aj)
  return cliffs(ai,aj)
}
function cliffs(as,bs,t,    a,b,n,lt,gt) {
  t= t? t : THE.stats.cliff
  for(a in as)
   for(b in bs) {
     n++
     if (as[a] < bs[b]) lt++
     if (as[a] > bs[b]) gt++
  }
  return abs(lt-gt)/n < t
}

